# SQL 调优场景分类体系
## 用途及说明
本文档描述了多种 SQL 优化，并按照不同场景划分，以用于再 datasets 目录下生成各个场景的测试集。

## 名词定义
在 datasets 目录下，每个子目录成称为 "评估数据集 (Evaluation Dataset)", 每一个 questions.md 中的问题&答案，称为 "评估样本 (Evaluation Instance)"；

## 重要原则
1. 以 datasets 目录下的 example 目录作为示例，严格遵循目录结构和文件格式； 
2. [重要]根据不同场景生成 dataset 时，应基于最小化原则，每个单一问题就是一个评估样本；
3. 标题应当以评估场景和数据库术语命名，而非业务名称，例如： "复合索引" 是合理的，"用户年龄和城市查询优化"是不允许的；
4. [重要]尤其注意各个评估样本不能存在重复，相似的情况，每次新增评估样本后都要在该场景下检索已有样本是否重复；

## 一、索引问题 (Indexing Issues)

### 1. 缺失索引 (Missing Indexes)
- **场景**: 查询条件或连接条件的列上没有索引，导致全表扫描
- **具体表现**:
  - `WHERE`、`JOIN ON`、`ORDER BY`、`GROUP BY` 子句中的列无索引
  - 频繁查询的字段组合（复合索引候选）无索引

### 2. 低效索引 (Inefficient Indexes)
- **场景**: 虽有索引，但设计不当导致效率低下
- **具体表现**:
  - **索引冗余**: 存在多个功能重叠的索引（如 `idx_a` 和 `idx_a_b`）
  - **索引未被使用**: 索引因函数、计算或类型转换而失效
  - **选择度低的索引**: 在区分度很低的列上建立索引

### 3. 索引失效 (Index Invalidation)
- **场景**: 索引因某种原因无法被使用
- **具体表现**:
  - 对索引列使用了函数、计算或表达式
  - 发生了隐式的类型转换
  - 使用了 `!=`, `NOT IN` 等否定操作符
  - 复合索引未遵循最左前缀匹配原则

## 二、执行计划问题 (Execution Plan Issues)

### 1. 统计信息不准确/过时 (Outdated Statistics)
- **场景**: 优化器基于陈旧的统计信息做出了错误判断
- **具体表现**:
  - 表数据量已发生巨大变化，但统计信息未更新
  - 数据分布严重倾斜，但统计信息未能体现

### 2. 优化器代价估算偏差 (Cost Estimate Deviation)
- **场景**: 优化器对不同操作的成本估算错误
- **具体表现**:
  - 本该走索引却走了全表扫描
  - 本该用哈希连接却用了嵌套循环（或反之）

### 3. 执行计划不稳定 (Plan Instability)
- **场景**: 同一SQL因传入参数不同，执行计划差异巨大
- **具体表现**:
  - **参数嗅探**: 第一次编译时传入的参数非常特殊，后续所有查询都沿用该计划

## 三、SQL编写问题 (SQL Writing Issues)

### 1. 访问路径问题 (Access Path Issues)
- **场景**: 读取了过多不需要的数据
- **具体表现**:
  - **二次回表**: SELECT * 查询需要回表获取所有列数据
  - **过滤条件太晚**: 大量数据在JOIN之后才在WHERE条件中被过滤

### 2. 操作符与函数滥用 (Operator/Function Misuse)
- **场景**: 使用了低效的SQL操作
- **具体表现**:
  - 在WHERE子句中对列使用函数或计算
  - 使用了 `SELECT *`
  - 使用了不必要的 `DISTINCT` 或 `GROUP BY`
  - 复杂的非必要子查询

### 3. 连接与子查询问题 (Join/Subquery Issues)
- **场景**: 表关联方式效率低下
- **具体表现**:
  - 该用 `JOIN` 时用了 `IN` 或 `EXISTS` 子查询（或反之）
  - 产生了笛卡尔积
  - 多层嵌套子查询

## 四、资源与配置问题 (Resource & Configuration Issues)

### 1. 资源配置不足 (Insufficient Resources)
- **场景**: 硬件或参数配置成为瓶颈
- **具体表现**:
  - 内存不足，导致排序、哈希连接等操作需要落盘
  - 工作内存设置过低
  - 并行度设置不合理

### 2. 对象设计问题 (Object Design Issues)
- **场景**: 表结构设计不合理
- **具体表现**:
  - 字段类型过大
  - 缺乏分区，导致查询需要扫描整个大表
  - 不必要的触发器或外键约束带来开销

### 3. 并发与锁竞争 (Concurrency & Locking Issues)
- **场景**: 多个会话争抢同一资源导致阻塞
- **具体表现**:
  - 长事务持有锁不释放
  - 事务隔离级别设置过高导致锁范围过大
  - 热点行更新竞争
